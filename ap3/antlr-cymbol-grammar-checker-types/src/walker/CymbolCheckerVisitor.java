package walker;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.antlr.v4.runtime.Token;

import autogenerated.CymbolBaseVisitor;
import autogenerated.CymbolParser;
import autogenerated.CymbolParser.AndOrExprContext;
import autogenerated.CymbolParser.BooleanExprContext;
import autogenerated.CymbolParser.ComparisonExprContext;
import autogenerated.CymbolParser.EqExprContext;
import autogenerated.CymbolParser.FormTypeBooleanContext;
import autogenerated.CymbolParser.FormTypeFloatContext;
import autogenerated.CymbolParser.FormTypeIntContext;
import autogenerated.CymbolParser.FormTypeStringContext;
import autogenerated.CymbolParser.FormTypeVoidContext;
import autogenerated.CymbolParser.FuncDeclContext;
import autogenerated.CymbolParser.FunctionCallExprContext;
import autogenerated.CymbolParser.IfStatContext;
import autogenerated.CymbolParser.MulDivExprContext;
import autogenerated.CymbolParser.NotExprContext;
import autogenerated.CymbolParser.ParamTypeContext;
import autogenerated.CymbolParser.ReturnStatContext;
import autogenerated.CymbolParser.SignedExprContext;
import autogenerated.CymbolParser.StringExprContext;

public class CymbolCheckerVisitor extends CymbolBaseVisitor<Type> {
	public Map<String, Type> symbolTable = new HashMap<String, Type>();
	public Map<String, Type> funcTypeTable = new HashMap<String, Type>();
	public Map<String, List<Type>> funcParamsTable = new HashMap<String, List<Type>>();
	public Type currentReturnType = null;

	@Override
	public Type visitFuncDecl(FuncDeclContext ctx) {
		String typeName = ctx.type().getText();
		Type type = Type.valueOf(typeName.toUpperCase());
		String name = ctx.ID().getText();

		if (funcTypeTable.containsKey(name)) {
			Token token = (Token) ctx.ID().getPayload();
			int line = token.getLine();
			int column = token.getCharPositionInLine();
			System.err.format("erro: funcao %s sendo declarada pela segunda vez na linha %d, coluna %d", name, line,
					column);
			System.exit(1);
		}

		funcTypeTable.put(name, type);

		ArrayList<Type> parameters = new ArrayList<Type>();

		currentReturnType = type;

		if (ctx.paramTypeList() != null) {
			List<CymbolParser.ParamTypeContext> parameterList = ctx.paramTypeList().paramType();
			for (int i = 0; i < parameterList.size(); i++) {
				ParamTypeContext current = parameterList.get(i);
				String id = current.ID().getText();
				Type currentType = Type.valueOf(current.type().getText().toUpperCase());
				symbolTable.put(id, currentType);
				parameters.add(currentType);
			}
		}

		funcParamsTable.put(name, parameters);

		visit(ctx.block());
		currentReturnType = null;
		return type;
	}

	@Override
	public Type visitIfStat(IfStatContext ctx) {
		Type result = visit(ctx.expr());

		if (result != Type.BOOLEAN) {
			int line = ctx.getStart().getLine();
			int column = ctx.getStart().getCharPositionInLine();
			System.err.format(
					"erro: if apresenta argumentos do tipo %s quando era esperado o tipo %s na linha %d, coluna %d",
					result.name(), Type.BOOLEAN.name(), line, column);
			System.exit(1);
		}

		visit(ctx.ifElseExprStat());

		return result;
	}

	@Override
	public Type visitReturnStat(ReturnStatContext ctx) {
		Type result = Type.VOID;
		if (ctx.expr() != null) {
			result = visit(ctx.expr());
		}

		if (currentReturnType == null || !isAssignCompatible(currentReturnType, result)) {
			int line = ctx.getStart().getLine();
			int column = ctx.getStart().getCharPositionInLine();
			System.err.format("erro: retorno do tipo %s invalido para funcao do tipo %s linha %d, coluna %d",
					result.name(), currentReturnType.name(), line, column);
			System.exit(1);
		}

		return result;
	}

	@Override
	public Type visitVarDecl(CymbolParser.VarDeclContext ctx) {
		// type ID = expr;
		String varname = ctx.ID().getText();
		String typeName = ctx.type().getText();
		Type type = Type.valueOf(typeName.toUpperCase());

		Token token = (Token) ctx.ID().getPayload();
		int line = token.getLine();
		int column = token.getCharPositionInLine();

		if (symbolTable.containsKey(varname)) {
			System.err.format("erro: dupla declaracao de variavel na linha %d, coluna %d", line, column);
			System.exit(1);
		}

		if (type.equals(Type.VOID)) {
			System.err.format("erro: variavel sendo criada com tipo vazio na linha %d, coluna %d", line, column);
			System.exit(1);
		}

		if (ctx.expr() != null) {
			Type exprType = visit(ctx.expr());

			if (!isAssignCompatible(type, exprType)) {
				System.err.format("erro: tentativa de atribuir um %s a um %s na linha %d, coluna %d", exprType.name(),
						type.name(), line, column);
				System.exit(1);
			}
		}

		symbolTable.put(varname, type);
		return type;
	}

	@Override
	public Type visitFunctionCallExpr(FunctionCallExprContext ctx) {
		String funcName = ctx.ID().getText();

		if (!funcTypeTable.containsKey(funcName)) {
			Token token = (Token) ctx.ID().getPayload();
			int line = token.getLine();
			int column = token.getCharPositionInLine();

			System.err.format("error: chamada de função não declarada na linha %d, coluna %d", line, column);
			System.exit(1);
		}

		List<Type> params = funcParamsTable.get(funcName);

		if (ctx.exprList() != null) {
			List<CymbolParser.ExprContext> current = ctx.exprList().expr();

			for (int i = 0; i < current.size(); i++) {
				if (i >= params.size()) {
					Token token = (Token) ctx.ID().getPayload();
					int line = token.getLine();
					int column = token.getCharPositionInLine();
					System.err.format("erro: Chamada de função invalida na linha %d, coluna %d", line, column);
					System.exit(1);
				}

				Type currentType = visit(current.get(i));
				Type argumentType = params.get(i);

				if (!isAssignCompatible(argumentType, currentType)) {
					Token token = (Token) ctx.ID().getPayload();
					int line = token.getLine();
					int column = token.getCharPositionInLine();
					System.err.format("erro: Chamada de função invalida na linha %d, coluna %d", line, column);
					System.exit(1);
				}
			}
		} else if (params.size() > 0) {
			Token token = (Token) ctx.ID().getPayload();
			int line = token.getLine();
			int column = token.getCharPositionInLine();
			System.err.format("erro: Chamada de função invalida na linha %d, coluna %d", line, column);
			System.exit(1);
		}

		return funcTypeTable.get(funcName);
	}

	@Override
	public Type visitAndOrExpr(AndOrExprContext ctx) {
		Type right = visit(ctx.expr(0));
		Type left = visit(ctx.expr(1));

		if (right != Type.BOOLEAN || left != Type.BOOLEAN) {
			int line = ctx.op.getLine();
			int column = ctx.op.getCharPositionInLine();
			System.err.format("erro: operador %s não definido para comparacao entre %s e %s na linha %d, coluna %d",
					ctx.op.getText(), right.name(), left.name(), line, column);
			System.exit(1);
		}

		return Type.BOOLEAN;
	}

	@Override
	public Type visitEqExpr(EqExprContext ctx) {
		Type right = visit(ctx.expr(0));
		Type left = visit(ctx.expr(1));

		if (left != right && ((left != Type.INT && left != Type.FLOAT) || (right != Type.INT && right != Type.FLOAT))) {

			int line = ctx.op.getLine();
			int column = ctx.op.getCharPositionInLine();
			System.err.format("erro: operador %s não definido para comparacao entre %s e %s na linha %d, coluna %d",
					ctx.op.getText(), right.name(), left.name(), line, column);
			System.exit(1);
		}

		return Type.BOOLEAN;
	}

	@Override
	public Type visitAddSubExpr(CymbolParser.AddSubExprContext ctx) {
		Type result;
		Type left = visit(ctx.expr(0));
		Type right = visit(ctx.expr(1));
		String operation = ctx.op.getText();

		if (((right == Type.BOOLEAN && (left != Type.STRING || operation.contains("-"))
				|| (left == Type.BOOLEAN && (right != Type.STRING || operation.contains("-")))))
				|| (operation.contains("-") && (right == Type.STRING || left == Type.STRING)) || right == Type.VOID
				|| left == Type.VOID) {
			int line = ctx.op.getLine();
			int column = ctx.op.getCharPositionInLine();
			System.err.format("erro: operador %s não definido entre %s e %s na linha %d, coluna %d", ctx.op.getText(),
					right.name(), left.name(), line, column);
			System.exit(1);
		}

		if (operation.contains("+") && (right == Type.STRING || left == Type.STRING)) {
			result = Type.STRING;
		} else if (right == Type.FLOAT || left == Type.FLOAT) {
			result = Type.FLOAT;
		} else {
			result = Type.INT;
		}

		return result;
	}

	@Override
	public Type visitMulDivExpr(MulDivExprContext ctx) {
		Type left = visit(ctx.expr(0));
		Type right = visit(ctx.expr(1));
		Type result;
		if ((left != Type.INT && left != Type.FLOAT) || (right != Type.INT && right != Type.FLOAT) || right == Type.VOID
				|| left == Type.VOID) {

			int line = ctx.op.getLine();
			int column = ctx.op.getCharPositionInLine();
			System.err.format("erro: operador %s não definido para comparacao entre %s e %s na linha %d, coluna %d",
					ctx.op.getText(), right.name(), left.name(), line, column);
			System.exit(1);
		}

		if (left == Type.FLOAT || right == Type.FLOAT)
			result = Type.FLOAT;
		else
			result = Type.INT;

		return result;
	}

	@Override
	public Type visitComparisonExpr(ComparisonExprContext ctx) {

		Type left = visit(ctx.expr(0));
		Type right = visit(ctx.expr(1));

		if ((left != Type.INT && left != Type.FLOAT)
				|| (right != Type.INT && right != Type.FLOAT || right == Type.VOID || left == Type.VOID)) {

			int line = ctx.op.getLine();
			int column = ctx.op.getCharPositionInLine();
			System.err.format("erro: operator %s não definido para comparacao entre %s e %s na linha %d, coluna %d",
					ctx.op.getText(), right.name(), left.name(), line, column);
			System.exit(1);
		}

		return Type.BOOLEAN;
	}

	@Override
	public Type visitNotExpr(NotExprContext ctx) {
		Type result = visit(ctx.expr());
		if (result != Type.BOOLEAN) {
			int line = ctx.expr().getStart().getLine();
			int column = ctx.expr().getStart().getCharPositionInLine();

			System.err.format("erro: operacao ! indefinida para o tipo %s na linha %d, coluna %d", result.name(), line,
					column);
			System.exit(1);
		}

		return result;
	}

	@Override
	public Type visitSignedExpr(SignedExprContext ctx) {
		// +a ou -a
		Type result = visit(ctx.expr());

		if (result != Type.INT && result != Type.FLOAT) {
			int line = ctx.expr().getStart().getLine();
			int column = ctx.op.getCharPositionInLine();

			System.err.format("erro: uso de '%s' em com tipo incompatível %s na linha %d, coluna %d", ctx.op.getText(),
					result.name(), line, column);
			System.exit(1);
		}

		return result;
	}

	@Override
	public Type visitVarIdExpr(CymbolParser.VarIdExprContext ctx) {
		Type t = symbolTable.get(ctx.ID().getText());

		if (t == null) {
			Token token = (Token) ctx.ID().getPayload();
			int line = token.getLine();
			int column = token.getCharPositionInLine();

			System.err.format("erro: uso de variavel não declarada na linha %d, coluna %d", line, column);
			System.exit(1);
		}

		return t;
	}

	private boolean isAssignCompatible(Type first, Type second) {
		return first == second || (first == Type.FLOAT && second == Type.INT);
	}

	@Override
	public Type visitIntExpr(CymbolParser.IntExprContext ctx) {
		return Type.INT;
	}

	@Override
	public Type visitFloatExpr(CymbolParser.FloatExprContext ctx) {
		return Type.FLOAT;
	}

	@Override
	public Type visitStringExpr(StringExprContext ctx) {
		return Type.STRING;
	}

	@Override
	public Type visitBooleanExpr(BooleanExprContext ctx) {
		return Type.BOOLEAN;
	}

	@Override
	public Type visitFormTypeBoolean(FormTypeBooleanContext ctx) {
		return Type.BOOLEAN;
	}

	@Override
	public Type visitFormTypeFloat(FormTypeFloatContext ctx) {
		return Type.FLOAT;
	}

	@Override
	public Type visitFormTypeInt(FormTypeIntContext ctx) {
		return Type.INT;
	}

	@Override
	public Type visitFormTypeString(FormTypeStringContext ctx) {
		return Type.STRING;
	}

	@Override
	public Type visitFormTypeVoid(FormTypeVoidContext ctx) {
		return Type.VOID;
	}

	@Override
	protected Type aggregateResult(Type aggregate, Type nextResult) {
		return (nextResult != null) ? nextResult : aggregate;
	}
}
