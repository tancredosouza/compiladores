package walker;

import java.util.HashMap;
import java.util.Map;

import autogenerated.CymbolBaseVisitor;
import autogenerated.CymbolParser;
import autogenerated.CymbolParser.SignedExprContext;



public class CymbolCheckerVisitor extends CymbolBaseVisitor<Type> {
	public Map<String, Type> symbolTable = new HashMap<String,Type>( ); 
	
	@Override
	public Type visitIntExpr(CymbolParser.IntExprContext ctx) {
		return Type.INT;
	}
	
	@Override
	public Type visitBoolExpr(CymbolParser.BoolExprContext ctx) {
		return Type.BOOLEAN;
	}
	
	@Override
	public Type visitFloatExpr(CymbolParser.FloatExprContext ctx) {
		return Type.FLOAT;
	}
	
	@Override
	public Type visitStringExpr(CymbolParser.StringExprContext ctx) {
		return Type.STRING;
	}
	
	@Override
	public Type visitVarDecl(CymbolParser.VarDeclContext ctx) {
		Type result;
		String varname = ctx.ID( ).getText( );
		String typeName = ctx.type( ).getText( );
		Type type = Type.valueOf(typeName.toUpperCase( ));
		
		if(symbolTable.containsKey(varname)) {
			result = Type.VOID;
			System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.start.getCharPositionInLine() + ": already declared variable.");
			System.exit(1); 
		}
		
		if (type.equals(Type.VOID)) {
			result = Type.VOID;
			System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.start.getCharPositionInLine() + ": variable of type void!");
			System.exit(1); 
		} else {
			if (ctx.expr( ) != null) {
				Type init = ctx.expr( ).accept(this);
				if (!(init.equals(Type.INT) && type.equals(Type.FLOAT)) && !init.equals(type)) {
					System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.start.getCharPositionInLine() + ": "
							+ "expected " + type + " but received " + init + " instead.");
					System.exit(2);
				} 
			}
					
			symbolTable.put(varname, type);
			result = type;
		}
		
		//System.out.println("var: " + varname + "; type: " + typeName);
		
		return result;
	}

	@Override
	public Type visitAddSubExpr(CymbolParser.AddSubExprContext ctx) {
		Type result;
		Type left = ctx.expr(0).accept(this);
		Type right = ctx.expr(1).accept(this);
		
		if (left.equals(Type.INT) && right.equals(Type.INT)) {
			result = Type.INT;
		}
		
		else if (left.equals(Type.INT) || right.equals(Type.INT)) {
			if (left.equals(Type.FLOAT) || right.equals(Type.FLOAT)) {
				result = Type.FLOAT;
			} 
			else if (left.equals(Type.STRING) || right.equals(Type.STRING)) {
				result = Type.STRING;
			} 
			
			else {
				result = Type.VOID;
				System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.start.getCharPositionInLine() 
									+ ": unexpected type variable.");
				System.exit(1); 
				return result;
			}
		} 
		
		else if (left.equals(Type.FLOAT) && right.equals(Type.FLOAT)){
			result = Type.FLOAT;
		}
		
		else if (left.equals(Type.STRING) && right.equals(Type.STRING)) {
			result = Type.STRING;
		} else {
			result = Type.VOID;
			System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.getStart().getCharPositionInLine() 
			+ ": unexpected type variable.");
			System.exit(1);
			return result;
		}
		
		return result;
	}
	
	@Override
	public Type visitMulDivExpr(CymbolParser.MulDivExprContext ctx) {
		Type result;
		Type left = ctx.expr(0).accept(this);
		Type right = ctx.expr(1).accept(this);
		
		if (left.equals(Type.INT) && right.equals(Type.INT)) {
			result = Type.INT;
		}
		
		else if (left.equals(Type.INT) || right.equals(Type.INT)) {
			if (left.equals(Type.FLOAT) || right.equals(Type.FLOAT)) {
				result = Type.FLOAT;
			} 
			else {
				result = Type.VOID;
				System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.start.getCharPositionInLine() 
				+ ": unexpected type variable. expected was FLOAT");
				return result;
			}
		}
		else if (left.equals(Type.FLOAT) && right.equals(Type.FLOAT)){
			result = Type.FLOAT;
		} else {
			result = Type.VOID;
			System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.start.getCharPositionInLine() 
			+ ": unexpected type variable. expected was INT");
			return result;
		}
		
		return result;
	}
	
	@Override
	public Type visitVarIdExpr(CymbolParser.VarIdExprContext ctx) {
		Type result;
		Type t = symbolTable.get(ctx.ID( ).getText( ));
		if (t == null) {
			result = Type.VOID;
			System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.start.getCharPositionInLine() 
			+ ": undeclared variable '" + ctx.ID().getText() + "'");
			System.exit(1);
		} else {
			result = t;
		}
		
		return result;
	}
	
	public Type visitComparisonExpr(CymbolParser.ComparisonExprContext ctx) {
		Type result;
		Type left = ctx.expr(0).accept(this);
		Type right = ctx.expr(1).accept(this);
		
		if(!left.equals(right)) {
			result = Type.VOID;
			System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.start.getCharPositionInLine() 
			+ ": cannot compare '" + left + "' with '" + right + "'.");
			System.exit(5);
		} else {
			result = Type.BOOLEAN;
		}
		
		return result;
	}
	
	public Type visitNotExpr(CymbolParser.NotExprContext ctx) {
		Type result;
		Type t = ctx.expr().accept(this);
		
		if(!t.equals(Type.BOOLEAN)) {
			result = Type.VOID;
			System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.start.getCharPositionInLine() 
			+ ": unexpected type variable. expected was 'BOOLEAN' but received '" + t + "' instead.");
			System.exit(6);
		} else {
			result = Type.BOOLEAN;
		}
		
		return result;
	}

	public Type visitSignedExpr(CymbolParser.SignedExprContext ctx) {
		Type result;
		Type t = ctx.expr().accept(this);
		
		if(!t.equals(Type.INT) && !t.equals(Type.FLOAT)) {
			result = Type.VOID;
			System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.start.getCharPositionInLine() 
			+ ": unexpected '" + t + "' expression.");
			System.exit(6);
		} else {
			result = t;
		}
		
		return result;
	}
	
	@Override
	public Type visitLogicExpr(CymbolParser.LogicExprContext ctx) {
		Type result;
		Type left = ctx.expr(0).accept(this);
		Type right = ctx.expr(1).accept(this);
		
		if (!left.equals(Type.BOOLEAN) || !right.equals(Type.BOOLEAN)) {
			result = Type.VOID;
			System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.start.getCharPositionInLine() 
			+ ": unexpected two 'BOOLEAN' expressions.");
			System.exit(6);
		} else {
			result = Type.BOOLEAN;
		}
		
		return result;
	}
	
	@Override
	public Type visitEqExpr(CymbolParser.EqExprContext ctx) {
		Type result;
		Type left = ctx.expr(0).accept(this);
		Type right = ctx.expr(1).accept(this);
		
		if(!left.equals(right)) {
			result = Type.VOID;
			System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.start.getCharPositionInLine() 
			+ ": undefined comparison between '" + left + "' and '" + right + "'.");
			System.exit(6);
		} else {
			result = Type.BOOLEAN;
		}
		
		return result;
	}
	
	@Override
	public Type visitFuncDecl(CymbolParser.FuncDeclContext ctx) {
		String funcName = ctx.ID( ).getText( );
		String funcType = ctx.type( ).getText( );

		Type type = Type.valueOf(funcType.toUpperCase( ));
		
		
		
		if(symbolTable.containsKey(funcName)) {
			System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.start.getCharPositionInLine() + ": already declared function.");
			System.exit(1); 
		}

		symbolTable.put(funcName, type);
		
		return type;
	}
	
	@Override
	public Type visitReturnStat(CymbolParser.ReturnStatContext ctx) {
		Type result = ctx.expr().accept(this);
		System.out.println(result);
		return result;
	}
	
	public Type visitFunctionCallExpr(CymbolParser.FunctionCallExprContext ctx) {
		String funcName = ctx.ID( ).getText( );
		
		Type result;
		if(!symbolTable.containsKey(funcName)) {
			result = Type.VOID;
			System.err.println("error line: " + ctx.start.getLine() + " column: " + ctx.start.getCharPositionInLine() + ": undeclared function '" + funcName + "'.");
			System.exit(1); 
		} else {
			result = symbolTable.get(funcName);
		}
		
		return result;
	}
	
	@Override
	public Type visitParenExpr(CymbolParser.ParenExprContext ctx) {
		Type result = ctx.expr().accept(this);
		
		return result;
	}
	
	@Override
	protected Type aggregateResult(Type aggregate, Type nextResult) {
		return (nextResult != null) ? nextResult : aggregate;
	}
}
