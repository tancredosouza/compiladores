package walker;

import java.util.HashMap;
import java.util.Map;

import autogenerated.CymbolBaseVisitor;
import autogenerated.CymbolParser;
import autogenerated.CymbolParser.SignedExprContext;



public class CymbolCheckerVisitor extends CymbolBaseVisitor<Type> {
	public Map<String, Type> symbolTable = new HashMap<String,Type>( ); 
	
	@Override
	public Type visitIntExpr(CymbolParser.IntExprContext ctx) {
		return Type.INT;
	}
	
	@Override
	public Type visitBoolExpr(CymbolParser.BoolExprContext ctx) {
		return Type.BOOLEAN;
	}
	
	@Override
	public Type visitFloatExpr(CymbolParser.FloatExprContext ctx) {
		return Type.FLOAT;
	}
	
	@Override
	public Type visitStringExpr(CymbolParser.StringExprContext ctx) {
		return Type.STRING;
	}
	
	@Override
	public Type visitVarDecl(CymbolParser.VarDeclContext ctx) {
		Type result;
		String varname = ctx.ID( ).getText( );
		String typeName = ctx.type( ).getText( );
		Type type = Type.valueOf(typeName.toUpperCase( ));
		
		if(symbolTable.containsKey(varname)) {
			result = Type.VOID;
			System.err.println("Variavel ja declarada!");
			System.exit(1); 
		}
		
		if (type.equals(Type.VOID)) {
			result = Type.VOID;
			System.err.println("Mensagem de erro 1...");
			System.exit(1);
		} else {
			if (ctx.expr( ) != null) {
				Type init = ctx.expr( ).accept(this);
				if (!(init.equals(Type.INT) && type.equals(Type.FLOAT)) && !init.equals(type)) {
					System.err.println("Mensagem de erro 2...");
					System.exit(2);
				} 
			}
					
			symbolTable.put(varname, type);
			result = type;
		}
		
		System.out.println("var: " + varname + "; type: " + typeName);
		
		return result;
	}

	@Override
	public Type visitAddSubExpr(CymbolParser.AddSubExprContext ctx) {
		Type result;
		Type left = ctx.expr(0).accept(this);
		Type right = ctx.expr(1).accept(this);
		
		if (left.equals(Type.INT) && right.equals(Type.INT)) {
			result = Type.INT;
		}
		
		else if (left.equals(Type.INT) || right.equals(Type.INT)) {
			if (left.equals(Type.FLOAT) || right.equals(Type.FLOAT)) {
				result = Type.FLOAT;
			} 
			else if (left.equals(Type.STRING) || right.equals(Type.STRING)) {
				result = Type.STRING;
			} 
			
			else if (left.equals(Type.VOID) || right.equals(Type.VOID)) {
				result = Type.VOID;
				System.out.println("mensagem de erro oxe");
				return result;
			} else {
				result = Type.INT;
			}
		} 
		
		else if (left.equals(Type.FLOAT) && right.equals(Type.FLOAT)){
			result = Type.FLOAT;
		}
		
		else if (left.equals(Type.STRING) && right.equals(Type.STRING)) {
			result = Type.STRING;
		} else {
			result = Type.VOID;
			System.out.println("mensagem de erro 3...");
			return result;
		}
		
		return result;
	}
	
	@Override
	public Type visitMulDivExpr(CymbolParser.MulDivExprContext ctx) {
		Type result;
		Type left = ctx.expr(0).accept(this);
		Type right = ctx.expr(1).accept(this);
		
		if (left.equals(Type.INT) && right.equals(Type.INT)) {
			result = Type.INT;
		}
		
		else if (left.equals(Type.INT) || right.equals(Type.INT)) {
			if (left.equals(Type.FLOAT) || right.equals(Type.FLOAT)) {
				result = Type.FLOAT;
			} 
			else {
				result = Type.VOID;
				System.out.println("mensagem de erro oxeee...");
				return result;
			}
		}
		else if (left.equals(Type.FLOAT) && right.equals(Type.FLOAT)){
			result = Type.FLOAT;
		} else {
			result = Type.VOID;
			System.out.println("mensagem de erro 3...");
			return result;
		}
		
		return result;
	}
	
	@Override
	public Type visitVarIdExpr(CymbolParser.VarIdExprContext ctx) {
		Type result;
		Type t = symbolTable.get(ctx.ID( ).getText( ));
		if (t == null) {
			result = Type.VOID;
			System.err.println("Mensagem de erro 4...");
			System.exit(4);
		} else {
			result = t;
		}
		
		return result;
	}
	
	public Type visitComparisonExpr(CymbolParser.ComparisonExprContext ctx) {
		Type result;
		Type left = ctx.expr(0).accept(this);
		Type right = ctx.expr(1).accept(this);
		
		if(!left.equals(right)) {
			result = Type.VOID;
			System.err.println("Mensagem de erro 5...");
			System.exit(5);
		} else {
			result = Type.BOOLEAN;
		}
		
		return result;
	}
	
	public Type visitNotExpr(CymbolParser.NotExprContext ctx) {
		Type result;
		Type t = ctx.expr().accept(this);
		
		if(!t.equals(Type.BOOLEAN)) {
			result = Type.VOID;
			System.err.println("Mensagem de erro 6...");
			System.exit(6);
		} else {
			result = Type.BOOLEAN;
		}
		
		return result;
	}

	public Type visitSignedExpr(CymbolParser.SignedExprContext ctx) {
		Type result;
		Type t = ctx.expr().accept(this);
		
		if(!t.equals(Type.INT) && !t.equals(Type.FLOAT)) {
			result = Type.VOID;
			System.err.println("Mensagem de erro 8...");
			System.exit(8);
		} else {
			result = t;
		}
		
		return result;
	}
	
	@Override
	public Type visitLogicExpr(CymbolParser.LogicExprContext ctx) {
		Type result;
		Type left = ctx.expr(0).accept(this);
		Type right = ctx.expr(1).accept(this);
		
		if (!left.equals(Type.BOOLEAN) || !right.equals(Type.BOOLEAN)) {
			result = Type.VOID;
			System.err.println("Mensagem de erro 7...");
			System.exit(7);
		} else {
			result = Type.BOOLEAN;
		}
		
		return result;
	}
	
	@Override
	public Type visitEqExpr(CymbolParser.EqExprContext ctx) {
		Type result;
		Type left = ctx.expr(0).accept(this);
		Type right = ctx.expr(1).accept(this);
		
		if(!left.equals(right)) {
			result = Type.VOID;
			System.err.println("erro na igualdade");
			System.exit(9);
		} else {
			result = Type.BOOLEAN;
		}
		
		return result;
	}
	
	@Override
	public Type visitParenExpr(CymbolParser.ParenExprContext ctx) {
		Type result = ctx.expr().accept(this);
		
		return result;
	}
	
	@Override
	public Type visitFunctionCallExpr(CymbolParser.FunctionCallExprContext ctx) {
		
		
		
		return result;
	}
	
	@Override
	protected Type aggregateResult(Type aggregate, Type nextResult) {
		return (nextResult != null) ? nextResult : aggregate;
	}
}
